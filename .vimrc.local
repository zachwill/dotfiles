set nocompatible
let mapleader = ","

" filetype plugin's on
filetype on
filetype plugin on

" 256 colors on iTerm2
set t_Co=256

" Default color scheme
color textmate

" Backup directory
set nobackup
set nowritebackup
set dir=/tmp

" Clipboard functionality in iTerm vim
set clipboard=unnamed

" Normal whitespace stuff
set nowrap
set expandtab
set textwidth=79
set shiftwidth=2
set softtabstop=2

set number
set guifont=Droid\ Sans\ Mono:h12
set ruler
syntax on

" Always vsplit windows to the right of current one
set splitright

" Mouse support
if has("mouse")
  set mouse=a
endif
" Switch to windows on mouse click
set mousefocus
" Hide mouse pointer on insert mode.
set mousehide

" Commandline abbreviations for new tabs
ca tn tabnew
ca th tabp
ca tl tabn

" :Q! force quits now
command! -bar -bang Q quit<bang>

" :W writes, too
command! W write

" gm to go to the middle of a line
map gm :call cursor(0, virtcol('$')/2)<CR>

" Add Python ctags functionality
set tags+=$HOME/.vim/tags/python.ctags

" Optimal commands for working with ctags
map gt :TlistToggle<CR>
map g] <C-]>
map g[ :pop<CR>
map gn :tnext<CR>

" Alt-. to repeat but cursor remain where it was before the command.
nmap <A-.> .`[

" Ctrl-Y to paste word above cursor.
noremap! <C-Y> <Esc>klyWjpa

" Ctrl+A to end of line in insert mode
imap <C-A> <C-O>$
" Ctrl+E to end of word in insert mode
imap <C-E> <ESC>ea
" Ctrl+I to beginning of line in insert mode
imap <C-I> <ESC><S-I>

" Ctrl-N to disable search match highlight
nmap <silent> <C-N> :silent noh<CR>

" Ctrl-M to switch between 2 last buffers
nmap <C-M> :b#<CR>

" Easy window width resizing with +/_ keys
nmap + <C-W>>
nmap _ <C-W><

" StatusLine background should change on insert.
hi StatusLine ctermfg=18
au InsertEnter * hi StatusLine ctermfg=54
au InsertLeave * hi StatusLine ctermfg=18

" Proper indentation of braces for C-like languages
au FileType c,cpp,javascript,java,objc imap <buffer>{ {}<left><cr><cr><up><tab>

" Python Auto Complete
autocmd FileType python set omnifunc=pythoncomplete#Complete

" Python PEP8 styling.
function s:pythonWrapping()
    set shiftwidth=4
    set softtabstop=4
endfunction

" Python and C files need 4 spaces.
au FileType python,c call s:pythonWrapping()
" Python `print` matching.
au BufRead,BufNewFile *.py syn match print /print\s/

" Objective-C files shouldn't have Matlab filetypes.
au BufRead,BufNewFile *.m set ft=objc
let tlist_objc_settings = 'objc;i:interface;c:class;m:method;p:property'

" Set new Django HTML files to 'htmldjango.html' filetype.
" Allows template syntax + Sparkup plugin functionality.
au! FileType htmldjango set ft=htmldjango.html
" Set LESS CSS files to CSS filetype.
au! BufRead,BufNewFile *.less set ft=less.css
au BufRead,BufNewFile *.less call s:pythonWrapping()

" Get rid of end of line spaces
function! EOLSpaces()
  exe "1,$s/[ <tab>]*$//"
  exe "normal! gg<CR>"
endfunction

" Django tests need a different <leader>r configuration
function! DjangoTest(file_name)
  let file_name_str=a:file_name
  exe "nmap <buffer> <leader>r :!python manage.py test " . file_name_str . " <CR>"
endfunction

" ,r - Execute the current buffer with the current filetype
function! RunCommand()
  let lang = &ft
  if lang == 'javascript'
    let lang = 'node'
  elseif lang == 'c'
    let lang = 'gcc'
  endif
  exe "map <leader>r :w<CR>:!". lang . " %<CR>"
endfunction

" ,r to execute current buffer
au BufRead,BufNewFile * call RunCommand()

" ,p to execute Python script with pypy
au BufRead,BufNewFile *.py nmap <leader>p :w<Esc>:!pypy %<cr>
" ,8 to check Python file follows PEP 8 Style Guide
au BufRead,BufNewFile *.py nmap <leader>8 :w<Esc>:!pep8 %<cr>
" ,n to run nosetests with coverage
au BufRead,BufNewFile *.py nmap <leader>n :w<Esc>:!nosetests --with-coverage --cover-package=$PWD<cr>

" NERDTree configuration
let NERDTreeIgnore=['\.rbc$', '\~$', '\.sqlite3$', '\.py[c|o]$']
map <C-P> :NERDTreeToggle<CR>

" Shortcut for Align plugin
vmap <C-A> :Align

" Inserts the path of the currently edited file into a command
" Command mode: Ctrl+P or %%
cmap <C-P> <C-R>=expand("%:p:h") . "/"<CR>
cnoremap %% <C-R>=expand("%:p:h") . "/"<CR>

" Map ,cd to cd to current directory
map <leader>cd :ChangeDirectory %:p:h<CR>:pwd<CR>

" CommandT functionality with ,t or ,f
map <leader>f :CommandT<CR>
nmap ; :CommandT<CR>
" :flush will perform a CommandTFlush
ca flush CommandTFlush

" Show syntax highlighting groups for word under cursor
" by hitting Ctrl+L -- think L for language
nmap <C-L> :call <SID>SynStack()<CR>
function! <SID>SynStack()
  if !exists("*synstack")
    return
  endif
  echo map(synstack(line('.'), col('.')), 'synIDattr(v:val, "name")')
endfunc

" ,/ to invert comment on the current line/selection
nmap <leader>/ :call NERDComment(0, "invert")<cr>
vmap <leader>/ :call NERDComment(0, "invert")<cr>

" Workaround to get endwise.vim to work for Ruby files.
au BufRead,BufNewFile *.rb let g:SuperTabCrMapping = 0

" TextMate functionality with delimitMate
set backspace=2
let delimitMate_expand_cr = 1
let b:delimitMate_expand_cr = 1

" MiniBufExpl plugin settings
let g:miniBufExplVSplit = 25
let g:miniBufExplorerMoreThanOne = 100
let g:miniBufExplUseSingleClick = 1

" ,b to display current buffers list
nmap <Leader>b :MiniBufExplorer<cr>


" Add the virtualenv's site-packages to vim path
py << EOF
import os.path
import sys
import vim
if 'VIRTUAL_ENV' in os.environ:
    project_base_dir = os.environ['VIRTUAL_ENV']
    sys.path.insert(0, project_base_dir)
    activate_this = os.path.join(project_base_dir, 'bin/activate_this.py')
    execfile(activate_this, dict(__file__=activate_this))
EOF


" For more info: http://goo.gl/PD4Tv
" Execute shell command into new scratch buffer.
" Example -- :Shell git status
function! s:ExecuteInShell(command)
  let command = join(map(split(a:command), 'expand(v:val)'))
  let winnr = bufwinnr('^' . command . '$')
  silent! execute  winnr < 0 ? 'botright new ' . fnameescape(command) : winnr . 'wincmd w'
  setlocal buftype=nowrite bufhidden=wipe nobuflisted noswapfile nowrap number
  echo 'Execute ' . command . '...'
  silent! execute 'silent %!'. command
  silent! execute 'resize ' . line('$')
  silent! redraw
  silent! execute 'au BufUnload <buffer> execute bufwinnr(' . bufnr('#') . ') . ''wincmd w'''
  silent! execute 'nnoremap <silent> <buffer> <LocalLeader>r :call <SID>ExecuteInShell(''' . command . ''')<CR>'
  echo 'Shell command ' . command . ' executed.'
endfunction
command! -complete=shellcmd -nargs=+ Shell call s:ExecuteInShell(<q-args>)
ca shell Shell



" Taken from Carl/Yehuda's Janus gvimrc file.
" NERDTree updates to common bash commands -- cd, mkdir, etc.
" Wanted it when working with vim in iTerm.

" If the parameter is a directory, cd into it
function s:CdIfDirectory(directory)
  let explicitDirectory = isdirectory(a:directory)
  let directory = explicitDirectory || empty(a:directory)

  if explicitDirectory
    exe "cd " . a:directory
  endif

  if directory
    NERDTree
    wincmd p
    bd
  endif

  if explicitDirectory
    wincmd p
  endif
endfunction

" NERDTree utility function
function s:UpdateNERDTree(...)
  let stay = 0

  if(exists("a:1"))
    let stay = a:1
  end

  if exists("t:NERDTreeBufName")
    let nr = bufwinnr(t:NERDTreeBufName)
    if nr != -1
      exe nr . "wincmd w"
      exe substitute(mapcheck("R"), "<CR>", "", "")
      if !stay
        wincmd p
      end
    endif
  endif

  if exists(":CommandTFlush") == 2
    CommandTFlush
  endif
endfunction

" Utility functions to create file commands
function s:CommandCabbr(abbreviation, expansion)
  execute 'cabbrev ' . a:abbreviation . ' <c-r>=getcmdpos() == 1 && getcmdtype() == ":" ? "' . a:expansion . '" : "' . a:abbreviation . '"<CR>'
endfunction

function s:FileCommand(name, ...)
  if exists("a:1")
    let funcname = a:1
  else
    let funcname = a:name
  endif

  execute 'command -nargs=1 -complete=file ' . a:name . ' :call ' . funcname . '(<f-args>)'
endfunction

function s:DefineCommand(name, destination)
  call s:FileCommand(a:destination)
  call s:CommandCabbr(a:name, a:destination)
endfunction

" Public NERDTree-aware versions of builtin functions
function ChangeDirectory(dir, ...)
  execute "cd " . a:dir
  let stay = exists("a:1") ? a:1 : 1

  NERDTree

  if !stay
    wincmd p
  endif
endfunction

function Touch(file)
  execute "!touch " . a:file
  call s:UpdateNERDTree()
endfunction

function Remove(file)
  let current_path = expand("%")
  let removed_path = fnamemodify(a:file, ":p")

  if (current_path == removed_path) && (getbufvar("%", "&modified"))
    echo "You are trying to remove the file you are editing. Please close the buffer first."
  else
    execute "!rm " . a:file
  endif

  call s:UpdateNERDTree()
endfunction

function Mkdir(file)
  execute "!mkdir " . a:file
  call s:UpdateNERDTree()
endfunction

function Edit(file)
  if exists("b:NERDTreeRoot")
    wincmd p
  endif

  execute "e " . a:file

ruby << RUBY
  destination = File.expand_path(VIM.evaluate(%{system("dirname " . a:file)}))
  pwd         = File.expand_path(Dir.pwd)
  home        = pwd == File.expand_path("~")

  if home || Regexp.new("^" + Regexp.escape(pwd)) !~ destination
    VIM.command(%{call ChangeDirectory(system("dirname " . a:file), 0)})
  end
RUBY
  " Flush CommandT so that the file can be opened.
  execute ":CommandTFlush"
endfunction

" Define the NERDTree-aware aliases
call s:DefineCommand("cd", "ChangeDirectory")
call s:DefineCommand("touch", "Touch")
call s:DefineCommand("rm", "Remove")
call s:DefineCommand("e", "Edit")
call s:DefineCommand("mkdir", "Mkdir")
