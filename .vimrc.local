set nocompatible
let mapleader = ","

" filetype plugin's on
filetype on
filetype plugin on

" 256 colors on iTerm2
set t_Co=256

" Default color scheme
color textmate

" Backup directory
set nobackup
set nowritebackup
set dir=/tmp

" Clipboard functionality in iTerm vim
set clipboard=unnamed

" Normal whitespace stuff
set nowrap
set expandtab
set textwidth=79
set shiftwidth=2
set softtabstop=2

set number
set guifont=Droid\ Sans\ Mono:h12
set ruler
syntax on

" Mouse support
if has("mouse")
  set mouse=a
endif
" Switch to windows on mouse click
set mousefocus
" Hide mouse pointer on insert mode.
set mousehide

autocmd FileType python set omnifunc=pythoncomplete#Complete

" Python PEP8 styling
function s:pythonWrapping()
    set shiftwidth=4
    set softtabstop=4
endfunction

" Python files need 4 spaces
au FileType python call s:pythonWrapping()

au BufRead,BufNewFile *.py syn match print /print\s/

" Set new HTML files to 'htmldjango.html' filetype.
" Allows template syntax + Sparkup plugin functionality.
au! BufRead,BufNewFile *.html setf htmldjango.html

" Set .less files to CSS syntax
au BufRead,BufNewFile *.less setf css

function! Python_Eval_VSplit() range
  let src = tempname()
  let dst = tempname()
  execute ": " . a:firstline . "," . a:lastline . "w " . src
  execute ":!python " . src . " > " . dst
  execute ":pedit! " . dst
endfunction

" F7 to execute current python script and output into
" a new temporary buffer
au BufRead,BufNewFile *.py vmap <silent> <F7> :call Python_Eval_VSplit()<CR>
au BufRead,BufNewFile *.py nmap <silent> <F7> mzggVG<F7>`z

" ,r to execute current Python or Ruby script
au BufRead,BufNewFile *.py nmap <leader>r :w<Esc>:!python %<cr>
au BufRead,BufNewFile *.py nmap <leader>p :w<Esc>:!pypy %<cr>
au BufRead,BufNewFile *.rb nmap <leader>r :w<Esc>:!ruby %<cr>

" :Q! force quits now
command! -bar -bang Q quit<bang>

" :W writes, too
command! W :w

" Alt-. to repeat but cursor remain where it was before the command.
nmap <A-.> .`[

" Ctrl-Y to paste word above cursor.
noremap! <C-Y> <Esc>klyWjpa

" Ctrl+A to end of line in insert mode
imap <C-A> <C-O>$
" Ctrl+E to end of word in insert mode
imap <C-E> <ESC>ea
" Ctrl+I to beginning of line in insert mode
imap <C-I> <ESC><S-I>

" NERDTree configuration
let NERDTreeIgnore=['\.rbc$', '\~$', '\.py[c|o]$']
map <C-P> :NERDTreeToggle<CR>

" Inserts the path of the currently edited file into a command
" Command mode: Ctrl+P
cmap <C-P> <C-R>=expand("%:p:h") . "/" <CR>

" Ctrl-N to disable search match highlight
nmap <silent> <C-N> :silent noh<CR>

" Easy window width resizing with +/_ keys
nmap + <C-W>>
nmap _ <C-W><

" CommandT functionality with ,t
map <leader>t :CommandT<CR>

" Ctrl-M to switch between 2 last buffers
nmap <C-M> :b#<CR>

" Show syntax highlighting groups for word under cursor
" by hitting Ctrl+L -- think L for language
nmap <C-L> :call <SID>SynStack()<CR>
function! <SID>SynStack()
  if !exists("*synstack")
    return
  endif
  echo map(synstack(line('.'), col('.')), 'synIDattr(v:val, "name")')
endfunc

" ,/ to invert comment on the current line/selection
nmap <leader>/ :call NERDComment(0, "invert")<cr>
vmap <leader>/ :call NERDComment(0, "invert")<cr>

map gm :call cursor(0, virtcol('$')/2)<CR>

" Split current buffers into tabs
" command <leader>bt :bufdo tab split<CR>

" TextMate functionality with delimitMate
set backspace=2
let delimitMate_expand_cr = 1
let b:delimitMate_expand_cr = 1

" minibufexpl
let g:miniBufExplVSplit = 25
let g:miniBufExplorerMoreThanOne = 100
let g:miniBufExplUseSingleClick = 1

" ,b to display current buffers list
nmap <Leader>b :MiniBufExplorer<cr>

" For more info: http://goo.gl/PD4Tv
" Execute shell command into new scratch buffer.
" Example -- :Shell git status
function! s:ExecuteInShell(command)
  let command = join(map(split(a:command), 'expand(v:val)'))
  let winnr = bufwinnr('^' . command . '$')
  silent! execute  winnr < 0 ? 'botright new ' . fnameescape(command) : winnr . 'wincmd w'
  setlocal buftype=nowrite bufhidden=wipe nobuflisted noswapfile nowrap number
  echo 'Execute ' . command . '...'
  silent! execute 'silent %!'. command
  silent! execute 'resize ' . line('$')
  silent! redraw
  silent! execute 'au BufUnload <buffer> execute bufwinnr(' . bufnr('#') . ') . ''wincmd w'''
  silent! execute 'nnoremap <silent> <buffer> <LocalLeader>r :call <SID>ExecuteInShell(''' . command . ''')<CR>'
  echo 'Shell command ' . command . ' executed.'
endfunction
command! -complete=shellcmd -nargs=+ Shell call s:ExecuteInShell(<q-args>)
ca shell Shell
ca sh Shell



" Taken from Carl/Yehuda's Janus gvimrc file.
" NERDTree updates to common bash commands -- cd, mkdir, etc.
" Wanted it when working with vim in iTerm.

" If the parameter is a directory, cd into it
function s:CdIfDirectory(directory)
  let explicitDirectory = isdirectory(a:directory)
  let directory = explicitDirectory || empty(a:directory)

  if explicitDirectory
    exe "cd " . a:directory
  endif

  if directory
    NERDTree
    wincmd p
    bd
  endif

  if explicitDirectory
    wincmd p
  endif
endfunction

" NERDTree utility function
function s:UpdateNERDTree(...)
  let stay = 0

  if(exists("a:1"))
    let stay = a:1
  end

  if exists("t:NERDTreeBufName")
    let nr = bufwinnr(t:NERDTreeBufName)
    if nr != -1
      exe nr . "wincmd w"
      exe substitute(mapcheck("R"), "<CR>", "", "")
      if !stay
        wincmd p
      end
    endif
  endif

  if exists(":CommandTFlush") == 2
    CommandTFlush
  endif
endfunction

" Utility functions to create file commands
function s:CommandCabbr(abbreviation, expansion)
  execute 'cabbrev ' . a:abbreviation . ' <c-r>=getcmdpos() == 1 && getcmdtype() == ":" ? "' . a:expansion . '" : "' . a:abbreviation . '"<CR>'
endfunction

function s:FileCommand(name, ...)
  if exists("a:1")
    let funcname = a:1
  else
    let funcname = a:name
  endif

  execute 'command -nargs=1 -complete=file ' . a:name . ' :call ' . funcname . '(<f-args>)'
endfunction

function s:DefineCommand(name, destination)
  call s:FileCommand(a:destination)
  call s:CommandCabbr(a:name, a:destination)
endfunction

" Public NERDTree-aware versions of builtin functions
function ChangeDirectory(dir, ...)
  execute "cd " . a:dir
  let stay = exists("a:1") ? a:1 : 1

  NERDTree

  if !stay
    wincmd p
  endif
endfunction

function Touch(file)
  execute "!touch " . a:file
  call s:UpdateNERDTree()
endfunction

function Remove(file)
  let current_path = expand("%")
  let removed_path = fnamemodify(a:file, ":p")

  if (current_path == removed_path) && (getbufvar("%", "&modified"))
    echo "You are trying to remove the file you are editing. Please close the buffer first."
  else
    execute "!rm " . a:file
  endif

  call s:UpdateNERDTree()
endfunction

function Mkdir(file)
  execute "!mkdir " . a:file
  call s:UpdateNERDTree()
endfunction

function Edit(file)
  if exists("b:NERDTreeRoot")
    wincmd p
  endif

  execute "e " . a:file

ruby << RUBY
  destination = File.expand_path(VIM.evaluate(%{system("dirname " . a:file)}))
  pwd         = File.expand_path(Dir.pwd)
  home        = pwd == File.expand_path("~")

  if home || Regexp.new("^" + Regexp.escape(pwd)) !~ destination
    VIM.command(%{call ChangeDirectory(system("dirname " . a:file), 0)})
  end
RUBY
endfunction

" Define the NERDTree-aware aliases
call s:DefineCommand("cd", "ChangeDirectory")
call s:DefineCommand("touch", "Touch")
call s:DefineCommand("rm", "Remove")
call s:DefineCommand("e", "Edit")
call s:DefineCommand("mkdir", "Mkdir")
